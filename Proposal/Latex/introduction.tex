Secure multiparty computation (MPC) is a concept for securely computing (potentially probabilistic) functions with multiple parties involved. Each party has private input which must not be disclosed to the other parties. Based on these, the different parties jointly execute a protocol to obtain the function's result. In this context security of the executed protocol typically refers to the privacy of parties' inputs and correctness. To achieve privacy the protocol must ensure that no information about one party's input is leaked to any other parties beyond the function's result. Correctness is attained when the computed result equals the function's output based on the given inputs. To analyze these properties it is important to fix a reasonable attacker model, i.e. what the attacker is capable of. Honest-but-curious (semi-honest) attackers are passive attackers and don't acitvely intefere with the protocol. They follow instructions correctly and act as expected but try to learn more from the execution than they are supposed to. For a simple example imagine a protocol whose runtime for input $x$ is longer than for input $y$. By keeping track of the runtimes an attacker could learn about the other partie's input without deviating from the protocol. Malicious attackers on the other hand actively interfere with the protocol and can act differently than advised. It is easy to see that active attackers are more powerful, making active security a much stronger requirement than semi-honest security.\\
\ \\Since there are many areas of application where MPC is useful, general purpose frameworks were developed early on. With these, arbitrary algorithms can be executed as a secure MPC protocol. To achieve this, the frameworks take as input a description of the algorithm in a specific format, e.g. boolean curcuits, and generate a protocol that allows the parties to securely compute the result. After generating the protocol it is executed.\todo{Zitat, SoK}\\ 
Even though the idea of these general purpose frameworks has been around for many decades already and it has been proven that they fulfill the security requirements they are not used as much as one would expect. The main reason for this is that for many interesting problems general purpose frameworks create solutions that are not efficient enough to be used in practice. \todo{Zitat, SoK, [31], [68], [127], [128]} For these problems special-purpose algorithms with faster execution times need to be constructed. This allows them to be used in practice but involves much more work because security needs to be proven for every single solution seperately. \\
\ \\One such problem is finding a stable matching. A matching is a mapping between the members of two disjoint sets with regards to their respective preferences, i.e. a (potentially partial) order over the members of the other set. The matching is stable when there are no two members (one from each set) that aren't matched to each other, such that they would rather be matched to each other than to their assigned matches.\\ 
Such algorithms are used to for example match residents to residency programs\todo{Ztat, Doerner, 41} or students to public schools\todo{Zitat, Doerner, 1, 54}. It is worth noting that these are special cases where multiple  residents/students can be matched to the same member instead of a 1:1 matching. Obviously the best solution would be that every member is assigned to their first preference, but in reality this is rarely possible. Stable matchings are a desirable solution in such cases to still achive a high level of member satisfaction.\\
One solution for computing a stable matching is the Gale-Shapley algorithm, developed by David Gale and Lloyd Shapley\todo{Zitat}, which will also be the one we are interested in.\\ 
Ideally, the matching could be computed by a trusted thrid party to which the parties privately send their inputs. This way, both parties' inputs stay hidden to the other party and are only revealed to the commonly trusted party.
Relying on a commonly trusted party has several disadvantages. In many cases it is not even possible to find such a party. But even if it is possible it can be hard to find one and entail a lot of efforts. \\
This is exactly an application for secure MPC, i.e. for a protocol which essentially replaces this trusted third party by a secure real world protocol. Doerner et al.\todo{Zitat, Doerner} proposed a supposedly secure protocol for this application. Within the protocol they make use of a newly introduced oblivious data structue calles "oblivious linked multi-list" while executing their protocol based on the Gale-Shapley algorithm. The data structure uses data arrays combined with a method by Zahur et al. \todo{Zitat, Doerner, 63} to obliviously permute them. This provides the means to obliviously access data, thus hiding access patterns and the derivable information. The authors claim that using the OLML to securely implement the Gale-Shapley algorithm leads to a relativly efficient prrotocol in the honst-but-curios attacker model. Even though the authors give a rough intuition provided by arguing as to why security holds in this setting, it lacks a rigourous formal proof.\\ \citet{sok}\\
\citet{smas}\\
\citeauthor{smas}
\citep{htsi}