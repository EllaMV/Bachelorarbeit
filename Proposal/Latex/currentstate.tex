As mentioned above there are general purpose frameworks for MPC applicable to arbitrary functions. They take an arbitrary function and convert it so that MPC protocols can be applied. The idea of these has been around for many decades already but were not used in real-world applications for a long time because they were not efficient enough [TODO Zitat]. Over the years technical advances allowed for more feasible implementations leading to the development of various products, including tools like EMP-toolkit, Obliv-C or ObliVM. Even though there were huge improvements there are still limitations. In addition to efficiency problems Hastings et al. [TODO Zitat] for example point out lack of documentation and correctness erorrs [TODO Zitat].
One alternative way to securely compute a stable matching without expensive adjustments to classic protocols is to outsource the computation to a trusted third party. This way, both parties' inputs stay hidden to the other party and are only revealed to the commonly trusted party.
Relying on a commonly trusted party has many disadvantages. In many cases it is not even possible to find such a party. But even if it is possible it can be hard to find one and entail a lot of efforts. \\
To avoid this, even prior to Doerner et al. [TODO Zitat] specific-purose protocols to compute a stable matching that are carried out between the involved parties only were developed. Stable matching in the context of multiparty-computation comprises multiple different aspects, such as data access strategies or the underlying algorithm. Both of these are research topics of their own with several possible approaches and solutions. Naturally this yields various possibilities of combining them to solve the problem of securely computing a stable matching. As opposed to the discussed approach by Doerner et al. [TODO Zitat] which uses the Gale-Shapley algorithm, Blanton et al. [TODO Zitat] for example use Breadth First Search. Some examples of work prior to Doerner et al. [TODO Zitat] are the protocols of Golle [TODO Zitat] with roughly O$(n^5)$ public-key operations [TODO formatieren] or the previously best implementation of the Gale-Shapley algorithm with a runtime of over 33 hours, working on sets of 512 members each [TODO Zitat].