\citeauthor{smas}\\
Secure multiparty computation (MPC) is a concept for securely computing (potentially probabilistic) functions with multiple parties involved. Each party has private input which must not be disclosed to the other parties. Based on these, the different parties jointly execute a protocol to obtain the function's result. In this context security of the executed protocol typically refers to the privacy of parties' inputs and correctness. To achieve privacy the protocol must ensure that no information about one party's input is leaked to any other parties beyond the function's result. Correctness is attained when the computed result equals the function's output based on the given inputs. To analyse these properties it is important to fix a reasonable attacker model, i.e., what the attacker is capable of. Honest-but-curious (semi-honest) attackers are passive attackers and do not actively interfere with the protocol. They follow instructions correctly and act as expected but try to learn more from the execution than they are supposed to. For a simple example imagine a protocol whose runtime (measured in amount of rounds executed) for input $x$ is longer than for input $y$. By keeping track of the runtimes an attacker could learn about the other party's input without deviating from the protocol. Malicious attackers on the other hand actively interfere with the protocol and can act differently than advised. It is easy to see that active attackers are more powerful, making active security a stronger requirement than semi-honest security.\\
\ \\Since there are many areas of application where MPC is useful and it is of great theoretical interest, general purpose frameworks were developed early on. With these, arbitrary algorithms can be executed as a secure MPC protocol. To achieve this, the frameworks take as input a description of the algorithm in a specific format, e.g., boolean circuits, and generate a protocol that allows the parties to securely compute the result. After generating the protocol, it is executed.\\ 
Even though the idea of these general-purpose frameworks has been around for many decades already and it has been proven that they fulfil the security requirements they are not used as much as one would expect. The main reason for this is that for many interesting problems general purpose frameworks create solutions that are not efficient enough to be used in practice \citep{sok, mpusp, htpamg, htgaes}. For these problems special-purpose algorithms with faster execution times need to be constructed. This allows them to be used in practice but involves much more work because security needs to be proven for every single solution separately. \\
\ \\One such problem is finding a stable matching. A matching is a mapping between the members of two disjoint sets. Stable matchings also consider each member's preferences, i.e., a (potentially partial) order over the members of the other set. The matching is stable when there are no two matched pairs so that by switching partners the members get matched to a member of the other set, that they prefer over their current partner. Generally, it is possible to compute matchings where members of one set are matched to multiple members of the other set. The special case of one-to-one matchings is also known as \glqq Stable Marriage\grqq, getting its name from the idea of people from two groups being matched to get married.\\ 
Such algorithms are used to for example match residents to residency programs \citep{nrmp} or students to public schools \citep{sm}. It is worth noting that these are cases where multiple  residents/students can be matched to the same member instead of a one-to-one matching. Obviously, the best solution would be that every member is assigned to their first preference, but in reality, this is rarely possible. Stable matchings are a desirable solution in such cases to still achieve a high level of member satisfaction.\\
One solution for computing a stable one-to-one matching is the Gale-Shapley algorithm, developed by David Gale and Lloyd Shapley, which will also be the one we are interested in.\\ 
Ideally, the matching could be computed by a trusted third party to which the parties privately send their inputs. This way, both parties' inputs stay hidden to the other party and are only revealed to the commonly trusted party.
Relying on a commonly trusted party has several disadvantages. In many cases it is not even possible to find such a party. But even if it is possible, it can be hard to find one and entail a lot of efforts. \\
This is exactly an application for secure MPC, i.e., for a protocol which essentially replaces an ideal third party by a secure real-world protocol. Doerner et al. \citep{smas} proposed a supposedly secure protocol for this application. Within the protocol they make use of a newly introduced oblivious data structure called \emph{\glqq oblivious linked multi-list\grqq} (OLML) while executing their protocol based on the Gale-Shapley algorithm. The data structure uses data arrays combined with a method by Zahur et al. \citep{rsqo} to obliviously permute them. This provides the means to obliviously access data, thus hiding access patterns and the information derivable from these. The authors claim that using the OLML to securely implement the Gale-Shapley algorithm leads to a relatively efficient protocol in the honest-but-curios attacker model. Even though the authors argue why security holds in this setting, it lacks a rigorous formal proof.\\